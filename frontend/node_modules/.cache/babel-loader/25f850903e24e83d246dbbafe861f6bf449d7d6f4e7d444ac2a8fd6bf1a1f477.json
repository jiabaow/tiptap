{"ast":null,"code":"import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';\nimport { TextSelection, NodeSelection } from '@tiptap/pm/state';\nconst HorizontalRule = Node.create({\n  name: 'horizontalRule',\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: 'block',\n  parseHTML() {\n    return [{\n      tag: 'hr'\n    }];\n  },\n  renderHTML(_ref) {\n    let {\n      HTMLAttributes\n    } = _ref;\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => _ref2 => {\n        let {\n          chain,\n          state\n        } = _ref2;\n        const {\n          $to: $originTo\n        } = state.selection;\n        const currentChain = chain();\n        if ($originTo.parentOffset === 0) {\n          currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), {\n            type: this.name\n          });\n        } else {\n          currentChain.insertContent({\n            type: this.name\n          });\n        }\n        return currentChain\n        // set cursor after horizontal rule\n        .command(_ref3 => {\n          let {\n            tr,\n            dispatch\n          } = _ref3;\n          var _a;\n          if (dispatch) {\n            const {\n              $to\n            } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              if ($to.nodeAfter.isTextblock) {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n              } else if ($to.nodeAfter.isBlock) {\n                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n              } else {\n                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n              }\n            } else {\n              // add node after horizontal rule if it’s the end of the document\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [nodeInputRule({\n      find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n      type: this.type\n    })];\n  }\n});\nexport { HorizontalRule, HorizontalRule as default };","map":{"version":3,"names":["HorizontalRule","Node","create","name","addOptions","HTMLAttributes","group","parseHTML","tag","renderHTML","_ref","mergeAttributes","options","addCommands","setHorizontalRule","_ref2","chain","state","$to","$originTo","selection","currentChain","parentOffset","insertContentAt","Math","max","pos","type","insertContent","command","_ref3","tr","dispatch","posAfter","end","nodeAfter","isTextblock","setSelection","TextSelection","doc","isBlock","NodeSelection","node","_a","parent","contentMatch","defaultType","insert","scrollIntoView","run","addInputRules","nodeInputRule","find"],"sources":["/Users/wenjiabao/tiptap/frontend/node_modules/@tiptap/extension-horizontal-rule/src/horizontal-rule.ts"],"sourcesContent":["import { mergeAttributes, Node, nodeInputRule } from '@tiptap/core'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\n\nexport interface HorizontalRuleOptions {\n  HTMLAttributes: Record<string, any>\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    horizontalRule: {\n      /**\n       * Add a horizontal rule\n       */\n      setHorizontalRule: () => ReturnType\n    }\n  }\n}\n\nexport const HorizontalRule = Node.create<HorizontalRuleOptions>({\n  name: 'horizontalRule',\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n    }\n  },\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'hr' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)]\n  },\n\n  addCommands() {\n    return {\n      setHorizontalRule:\n        () => ({ chain, state }) => {\n          const { $to: $originTo } = state.selection\n\n          const currentChain = chain()\n\n          if ($originTo.parentOffset === 0) {\n            currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), { type: this.name })\n          } else {\n            currentChain.insertContent({ type: this.name })\n          }\n\n          return (\n            currentChain\n              // set cursor after horizontal rule\n              .command(({ tr, dispatch }) => {\n                if (dispatch) {\n                  const { $to } = tr.selection\n                  const posAfter = $to.end()\n\n                  if ($to.nodeAfter) {\n                    if ($to.nodeAfter.isTextblock) {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1))\n                    } else if ($to.nodeAfter.isBlock) {\n                      tr.setSelection(NodeSelection.create(tr.doc, $to.pos))\n                    } else {\n                      tr.setSelection(TextSelection.create(tr.doc, $to.pos))\n                    }\n                  } else {\n                    // add node after horizontal rule if it’s the end of the document\n                    const node = $to.parent.type.contentMatch.defaultType?.create()\n\n                    if (node) {\n                      tr.insert(posAfter, node)\n                      tr.setSelection(TextSelection.create(tr.doc, posAfter + 1))\n                    }\n                  }\n\n                  tr.scrollIntoView()\n                }\n\n                return true\n              })\n              .run()\n          )\n        },\n    }\n  },\n\n  addInputRules() {\n    return [\n      nodeInputRule({\n        find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type,\n      }),\n    ]\n  },\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}